Objetivo da aula:
- Compreender a estrutua de um projeto FastAPI e como estruturar rotas CRUD (Criar, Ler, Atualizar, Deletar)
- Aprimorar nosso conhecimento sobre Pydantic e sua utilidade na validação e serialização de dados
- Implementação de rotas CRUD em fastapi
- Escrita e execução de testes para validar o comportamento das rotas
---
# CRUD e HTTP
Quatro ações principais que fazemos com dados:
- Criar
- Ler
- Atualizar
- Excluir  
---
> CRUD é um acrônimo que representa as quatro operações básicas que você pode realizar em qualquer banco de dados persistente 
---
- C -> **CREATE**: Adicionar novos registros ao banco de dados
- R -> **Read**: Recuperar registros existentes do banco de dados
- U -> **Update**: Modificar registros existentes no banco de dados
- D -> **Deletar**: Remover registros existentes no banco de dados

Com isso, podemos executar qualquer tarefa em uma base de dados. 
- No HTTP temos verbos que indicam essas mesmas ações, que são:
	- **POST**: é usado para solicitar que o servidor aceite um dado (recurso) enviado pelo cliente
	- **GET**: é usado para quando o cliente deseja requisitar uma informação do servidor
	- **PUT**: é usado no momento em que o cliente deseja informar alguma alteração nos dados para o servidor
	- **DELETE**: usado para dizer ao servidor que delete determinado recurso
Desta forma, conseguimos fazer com que o cliente se comunique com o servidor de forma clara, identificando sua intenção no servidor (no caso deste curso, através do JSON)
## Respostas da API
Para termos certeza de que uma operação HTTP ocorreu corretamente através de uma API, precisamos de conhecer bem os códigos mais comuns. 
Os códigos de OK mais comuns:
- **200 OK**: Indica sucesso na requisição
	- **GET**: Quando um dado é solicitado e retornado com sucesso
	- **PUT**: Quando os dados são alterados com sucesso
- **201 CREATED**: Significa que a solicitação resultou na criação de um novo recurso
	- **POST**: Aplicável quando um dado é enviado e criado com sucesso
	- **PUT**: Usando quando uma alteração resulta na criação de um novo recurso
- **204 NO CONTENT**: Retorno do servidor sem conteúdo na mensagem
	- **PUT**: Aplicável se a alteração não gerar um retorno
	- **DELETE**: Usado quando a ação de deletar não gera um retorno.
Os códigos de erro mais comuns:
- **404 NOT FOUND**: O recurso solicitado não pôde ser encontrado
- **422 UNPROCESSABLE ENTITY**: O pedido foi bem formado (ou seja, sintaticamente correto), mas não pôde ser processado
- **500 INTERNAL SERVER ERROR**: Uma mensagem de erro genérica, dada quando uma condição inesperada foi encontrada. Geralmente ocorre quando nossa aplicação apresenta um erro.
# Implementando endpoints
três etapas para a criação de um novo endpoint:
1. **Relação com o HTTP**: Determinar o verbo HTTP esperado e os códigos de resposta para a situação de sucesso e erro.
2. **Modelos de dados**: Definir o formato do JSON esperado, campos e seus tipos, e pensar nos modelos de respostas para situações de sucesso e erro.
3. **Implementação do Corpo**: Decidir o tratamento dos dados recebidos e o tipo de processamento aplicado
As duas primeiras etapas nos ajuda a definir a interface de comunicação e como ela será documentada. Ja a terceira etapa é mais especifica e envolve decisões sobre interação com o banco de dados, validações adicionais e definição do que é sucesso e um erro na requisição

## Iniciando a implementação da rota POST
> Nesta aula, nosso foco principal será desenvolver um sistema de cadastro de usuários. Para isso, a implementação de uma forma eficiente para criar novos usuários na base de dados é essencial. Exploraremos como utilizar o verbo HTTP POST, fundamental para comunicar ao serviço a nossa intenção de enviar novos dados, como no cadastro de usuários.

### Implementação de endpois
- Criação do endpoint `POST` com saída JSON e resposta de sucesso `201`
- Em fastapi, para determinar o endpoint, o decorador é o `@app.post(/users/)`
```python
@app.post('/users/')
def create_user():
```
#### Status de resposta
- Ao criar um usuário, é necessário a devolução de uma resposta. Em caso de sucesso, usaremos a resposta `201` que ja foi visto anteriormente.
- No fastapi, podemos acrescentar no decorador da rota o status code:
```python
@app.post('/users/', status_code=HTTPStatus.CREATED)
def create_user():
```
> Não podemos esquecer que o status code no decorador é fornecido pelo `http` que tem um objeto chamado `HTMLStatus`, que nos retorna se o foi sucesso ou não. Com isso não precisamos digitar exatamente a mensagem esperada se erro ou acerto. Pois esse objeto ja se responsabiliza por isso.

#### Modelo de dados
> O modelo de dados é uma parte fundamental, onde consideramos tanto os dados recebidos do cliente quanto os dados que serão retornados a ele. Esta abordagem assegura uma comunicação eficaz e clara.
##### Modelo de entrada de dados
- Como é um CRUD de criação de usuários, precisamos definir quais dados são necessários para a criação destes determinados usuários. 
- Para a nossa aplicação, usaremos "username", "email", e "password". O que nos da uma possivel saida como:
```json
{
	"username": "joao123",
	"email": "joao123@email.com",
	"password": "segredo123"
}
```
- Para expor esse modelo, devo criar a classe pydantic em meu arquivo `schemas`:
```python
class UserSchema(BaseModel):
    username: str
    email: str
    password: str
```
- Com o endpoint definido, preciso fazer a associação a esse modelo.
- Para isso, a função recebe este objeto como parâmetro
```python
from fast_zero.schemas import Message, UserSchema

# ...

@app.post('/users/', status_code=HTTPStatus.CREATED)
def create_user(user: UserSchema):
```
- Com isso já é esperado ter uma rota POST no nosso swagger passando o Schema como esperado acima.
	
	![[Projetos/Estudos/FastAPI/attachments/Parameters.png|400]]

- Também apresenta outras coisas como as respostas.

	![[Responses.png| 400]]	
#### Modelo de Saída de dados
