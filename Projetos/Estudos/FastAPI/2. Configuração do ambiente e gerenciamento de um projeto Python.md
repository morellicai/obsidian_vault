**Objetivos dessa aula**:
- Introdução ao ambiente de desenvolvimento (terminal, ferramentas, etc.)
- Instalação do FastAPI e suas dependências
- Configuração das ferramentas de desenvolvimento
- Execução do primeiro "Hello, World!" com FastAPI com testes!

# Peças cruciais para um bom desenvolvimento
### pipx
- Ferramenta para instalar python globalmente de forma mais segura do que o pip
- Gera um ambiente virtual para que não suje outras áreas de dependências de python

- Instalação em arch:
```bash
sudo pacman -S python-pipx
```

- Para reconhecer o caminho das ferramentas instaladas, usamos o comando `pipx ensurepath` que adiciona esse path nas configurações. 
- Para certeza de que está configurado, utilizamos o mesmo comando com a flag `--force` 
### Poetry

> Gerenciador de projetos para python, como o venv. Pode nos ajudar em diversas etapas do ciclo de desenvolvimento, como a instalação de versões específicas do python, a criação e manutenção de projetos, (incluindo a definição de estruturas de pastas, o gerenciamento de ambientes virtuais e a instalação de bibliotecas). Além de permitir a publicação de pacotes

- Será o componente central para os projetos aqui propostos
##### Instalação:
```bash
pipx install poetry
```

- Para facilitar meu fluxo com ambientes virtuais, vou instalar uma extenção do Poetry 
```bash
pipx inject poetry poetry-plugin-shell
# Ou via poetry
poetry self add poetry-plugin-shell
```
- Essa extensão habilita o comando `poetry shell`, que habilita o ambiente virtual no terminal.
#### Gerenciamento de versões python 

- Podemos utilizar o poetry como gerenciador de versões, como escrito anteriormente, para acompanhar esse curso será preciso um python maior que 3.11, que é a versão minima suportada pelas dependências desse curso. 
- Posso instalar a versão mais atual do python também, o que sera sempre melhor.
- Mas no caso deste curso, vou instalar a mesma versão que ele usará. que é o `python 3.13`
- Para instalarmos no sistema, pedimos ao Poetry que instale a versão com o comando:
```bash
poetry python install 3.13
```

# Criando o projeto

- Primeiro passo é criar um novo projeto utilizando o Poetry, com o comando `poetry new`
- Depois iremos até o diretório
```bash
poetry new --flat fast_zero
cd fast_zero
```

- Foi criado com uma estrutura de arquivos e pastas assim:

```bash
├── contratos
│   └── __init__.py
├── pyproject.toml
├── README.md
└── tests
    └── __init__.py
```

- Agora que esta criado, preciso informar ao poetry qual versão de python vou utilizar, pra isso passo o comando `poetry env use 3.13`

## Instalando o FastAPI

-  A instalação do fastAPI com o poetry é:
```bash
poetry install
poetry add 'fastapi[standard]'
```

### Hello, World!

> Uma coisa bastante interessante dobre o FastAPI é que ele é um framework web baseado em funções. Da mesma forma em que criamos funções tradicionalmente em python, podemos estender essas funções para que elas sejam servidas pelo servidor. Por exemplo:
```python
def read_root():
    return {'message': 'Olá Mundo!'}
```

- A função acima é basicamente uma função que retorna um dicionário com uma chave chamada 'mensagem' e uma mensagem 'Olá mundo!'
- Podemos usar um decorador do FastAPI para que determinada função seja acessível pela rede:
```python
from fastapi import FastAPI 

app = FastAPI()  

@app.get('/')  
def read_root():  
    return {'message': 'Olá Mundo!'}
```

- A linha `app.get('/')` expõe a função para ser servida pelo FastAPI. Dizendo que quando o cliente acessar o endereço de rede no caminho `/`, usando o método HTTP GET, a função será executada. 
- Para iniciar o ambiente virtual, o poetry tem um comando expecifico no shell
	- `poetry shell`
	- Esse comando atica o virtualenv
- Depois do env ativado, iniciar o servidor fast api o comando é:
	- `fastapi dev <NOME_DA_APLICAÇÃO>
### Saída do comando
Quando dado o comando, ele inicia o servidor com algumas informações importantes. Uma delas é o `serving: http://127.0.0.1:8000` que nos é informado o:
- `http://` -> Protocolo da requisição
	- Protocolo padrão da web
- `127.0.0.1` -> Endereço
	- Endereço de rede (IP) que está escutando.
	- no caso, um loopback, que aponta para a própria maquina
- `:8000` -> Porta
	- A qual nossa maquina está reservada para nossa aplicaçãols
## Uvicorn

> Por si só, o fastapi não consegue criar um servidor real para rodar a aplicação por outros clientes. Com isso usamos o uvicorn, dependencia que ja vem instalado junto ao fastapi

- O que significa que quando executamos o comando do fastapi, ele roda o uvicorn para inicializar o servidor, por isso conseguimos acessar ele via curl ou até via navegador

> Ele deixa isso bem claro ali no final da execução do script com as infos:
```bash
INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO:     Started reloader process [893203] using WatchFiles
INFO:     Started server process [893207]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
```

## Instalando as ferramentas de desenvolvimento
> Ferramentas de desenvolvimento na sua grande parte são ferramentas para criar comandos, executar e criar testes e ter um linter ou mesmo formatador de cófigo para seguir boas práticas, como o PEP-8

###### Ferramentas escolhidas pelo curso para apresentar são:

- **Taskipy**: ferramenta usada para criação de comandos. Como executar a aplicação, rodar os testes, etc.
- **pytest**: ferramenta para escrever e executar testes
- **ruff**: Uma ferramenta que tem duas funções no nosso código:
	- Um analisador de código (linter), para dizer se não estamos infringindo alguma boa pratica de programação;
	- um formatador de código. Para seguirmos um estilo único de código.
#### Instalação
Para a instalação, o poetry tem como criar grupos onde podemos garantir que ele não sera instalada quando a aplicação estiver em produção.
- Para isso precisa-se de uma flag `--group`
```bash
poetry add --group dev pytest pytest-cov taskipy ruff
```

## Configurando as ferramentas
> Após a instalação das ferramentas, precisamos definir as configurações de cada uma no arquivo `pyproject.toml`

### [Ruff](https://docs.astral.sh/ruff/)

- Escrito em rust
- Tem duas funções principais:
	1. Analizar o código de forma estática (linter): Efetuar a verificação se estamos programando de acordo com boas práticas do python.
	2. Formatar o código (Formatter): Efetuar a verificação do código para padronizar um estilo ded código pré-definido.

Para configurar o ruff, criaremos 3 tabelas distintas de configuração. Uma para as configurações globais, uma para o linter e outra para o formatador
#### Configuração global
```toml
[tool.ruff]
line-length = 79
extend-exclude = ['migrations']
```
- _line-length_ -> Adicionando um limite de caracteres sugerido pela PEP-8
- _extend-exclue_ -> ignora o diretório de migrações de banco de dados da formatação
#### Linter

Durante a análise estática do código, queremos buscar por coisas específicas. No Ruff, precisamos dizer exatamente o que ele deve analisar. Isso é feito por códigos. Usaremos estes:

- `I` ([Isort](https://pycqa.github.io/isort/)): Checagem de ordenação de imports em ordem alfabética
- `F` ([Pyflakes](https://github.com/PyCQA/pyflakes)): Procura por alguns erros em relação a boas práticas de código
- `E` (Erros [pycodestyle](https://pycodestyle.pycqa.org/en/latest/)): Erros de estilo de código
- `W` (Avisos [pycodestyle](https://pycodestyle.pycqa.org/en/latest/)): Avisos de coisas não recomendadas no estilo de código
- `PL` ([Pylint](https://pylint.pycqa.org/en/latest/index.html)): Como o `F`, também procura por erros em relação a boas práticas de código
- `PT` ([flake8-pytest](https://pypi.org/project/flake8-pytest-style/)): Checagem de boas práticas do Pytest

```toml
[tool.ruff.lint]
preview = true
select = ['I', 'F', 'E', 'W', 'PL', 'PT']
```
#### Formatter

```toml
[tool.ruff.format]
preview = true
quote-style = 'single'
```

- Alteração feita no formatter é apenas o uso de aspas simples no lugar de aspas duplas
### pytest

O [Pytest](https://docs.pytest.org/) é uma framework de testes, que usaremos para escrever e executar nossos testes. O configuraremos para reconhecer o caminho base para execução dos testes na raiz do projeto `.`:

```toml
[tool.pytest.ini_options]
pythonpath = "."
addopts = '-p no:warnings'
```

- A segunda linha serve para ter uma visualização mais limpa dos testes
- Caso um erro aconteça de alguma biblioteca, o pytest suprimirá

### Taskipy

- Serve para complementar execução de tarefas na aplicação. 
- Para não lembrar de todas as execuções no terminal, podemos lembrar apenas de `task run`
- Funciona para qualquer comando complicado na aplicação
- Ajuda na execução de comandos

```toml
[tool.taskipy.tasks]
lint = 'ruff check'
pre_format = 'ruff check --fix'
format = 'ruff format'
run = 'fastapi dev contratos_project/app.py' # lembrar que é o nome da pasta aqui
pre_test = 'task lint'
test = 'pytest -s -x --cov=fast_zero -vv'
post_test = 'coverage html'
```

- `lint`: Faz a checagem de boas práticas do código python
- `pre_format`: Faz algumas correções de boas práticas automaticamente
- `format`: Executa a formatação do código em relação às convenções de estilo de código
- `run`: executa o servidor de desenvolvimento do FastAPI
- `pre_test`: executa a camada de lint antes de executar os testes
- `test`: executa os testes com pytest de forma verbosa (-vv) e adiciona nosso código como base de cobertura
- `post_test`: gera um report de cobertura após os testes

> Para executar um comando, só precisamos passar `task <comando>`

## Introdução ao Pytest
> Antes de entender a dinamica dos testes, preciso entender o efeito que eles tem no meu código. rodando no terminal o primeiro teste, a saída é essa:

```bash
❯ task test
All checks passed!
================================================================================= test session starts =================================================================================
platform linux -- Python 3.13.5, pytest-8.4.1, pluggy-1.6.0 -- /home/morelli/.cache/pypoetry/virtualenvs/fast-zero-x9TakeAS-py3.13/bin/python
cachedir: .pytest_cache
rootdir: /home/morelli/Documentos/Estudos/fastapi_do_zero/fast_zero
configfile: pyproject.toml
plugins: cov-6.2.1, anyio-4.10.0
collected 0 items
/home/morelli/.cache/pypoetry/virtualenvs/fast-zero-x9TakeAS-py3.13/lib/python3.13/site-packages/coverage/control.py:943: CoverageWarning: No data was collected. (no-data-collected)
  self._warn("No data was collected.", slug="no-data-collected")

================================= tests coverage ================================
___________________________________________________________________ coverage: platform linux, python 3.13.5-final-0 ___________________________________________________________________

Name                    Stmts   Miss  Cover
-------------------------------------------
fast_zero/__init__.py       0      0   100%
fast_zero/app.py            5      5     0%
-------------------------------------------
TOTAL                       5      5     0%
================================================================================ no tests ran in 0.03s ================================================================================
```

- A tabela que nesse caso contém a parte importante
- A coluna Coverage diz que não temos nenhuma linha de código coberto pelos testes. 
- Como não encontrou nenhum, teste, preciso rodar ele manualmente `task post_test`
- Me resulta uma página HTML que tem mais informações sobre o teste feito
- A saída que da é que não há testes sendo feitos, o que da como todas as linhas perdidas. pra isso, precisamos escrever os testes
#### Escrevendo os testes

- Por convenção todos os testes escritos com o pytest deve iniciar com o prefixo test_
- esse arquivo eu crio dentro do diretório de teste criado na execução da criação do diretório
- Para testar o código feito com FastAPI, precisamos de um cliente de teste. O fastAPI ja vem com um cliente de testes em um módulo `fastapi.testclient` com o objeto `testClient` e é preciso passar apenas o arquivo a ser testado como parâmetro
```python
from fastapi.testclient import TestClient  

from contratos_project.app import app  

client = TestClient(app)
```

Quando o teste é rodado, o unico erro que retorna, é a lógica da função criada no arquivo. Para resolver isso, precisamos incrementar o teste para um teste de verdade. Vamos fazer isso criando uma função que testa a função em app com o cliente criado. 

```python
from http import HTTPStatus

from fastapi.testclient import TestClient

from fast_zero.app import app


def test_root_deve_retornar_ok():
    client = TestClient(app)

    response = client.get('/')

    assert response.status_code == HTTPStatus.OK
```

#### Estrutura de um teste
> Agora que escrevemos nosso primeiro teste de forma intuitiva, podemos entender o que cada passo do teste faz. Essa compreensão é vital, pois nos ajudará a escrever testes com mais confiança e eficácia. Para desvendar o método por trás da nossa abordagem, exploraremos uma estratégia conhecida como [AAA](https://xp123.com/articles/3a-arrange-act-assert/), que divide o teste em três fases distintas: Arrange, Act, Assert.

- Para analisar as etapas, será usado o primeiro teste como exemplo
```python
from http import HTTPStatus

from fastapi.testclient import TestClient

from contratos_project.app import app


def test_root_deve_retornar_ok():
    client = TestClient(app) # Arrange

    response = client.get('/') # Act

    assert response.status_code == HTTPStatus.OK # Assert
```

Com base no nosso teste, podemos observar as 3 fases:

##### Fase 1 - Organizar (Arrange)
- Prepara o ambiente
- É onde monta o ambiente para o teste poder ser executado
- Neste caso, iniciamos um cliente para fazer a requisição ao app
##### Fase 2 - Agir (Act)
- Ação principal do teste
- Consiste em chamar o Sistema Sob Teste ([SUT](http://xunitpatterns.com/SUT.html))
- Nesse caso, o SUT é a rota / que é representada pela linha `response = client.get('/')`
	- Estamos exercitando a rota e armazenando sua resposta na variável `response`
- Diretamente interagir com a parte do sistema que queremos avaliar
##### Fase 3 - Afirmar (Assert)
- Verificar se tudo correu como esperado. 