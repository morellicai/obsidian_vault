---
tags:
  - Java
  - Faculdade
  - TecnicaProgramacao
Data:
Tarefa Feita: false
---
- [[0. Técnicas de Programação - Base |BASE]]
> Neste modulo, mergulhamos em conceitos cruciais para a programação orientada a objetos em Java, focando principalmente na proteção de dados (Encapsulamento), e na gestão do ciclo de vida dos objetos por meio de Construtores e Destrutores.

*Os objetivos centrais deste módulo são*:

- Utilizar o Encapsulamento para garantir a proteção dos dados.
- Demonstrar as funções de métodos construtores e destrutores.
- Criar Construtores e realizar a inicialização de objetos.
---
## Encapsulamento: A Proteção dos Dados

O Encapsulamento é fundamental e também é compreendido como **acessibilidade**. Ele define como os elementos (atributos e métodos) de uma classe podem ser vistos e utilizados por outras classes. Embora variáveis e métodos declarados sejam, por padrão, visíveis a todos os objetos criados, o encapsulamento permite ocultar certos métodos ou variáveis.

Restringir o acesso a partes da classe é uma necessidade que visa controlar seu uso, assegurando que variáveis de instância mantenham valores restritos, acessíveis somente pela classe em que foram definidas, e não por classes intermediárias.

**Modificadores de Acesso (Qualificadores)** Para definir o nível de acesso, são utilizados qualificadores:

- `{java} public` (público)
- `{java} private` (privado)
- `{java} package` (pacote)
- `{java} protected` (protegido)

As regras de visibilidade são:

- **Modificador Público (`public`):** Permite que classes, atributos e métodos sejam visíveis para **qualquer objeto** no programa.
- **Modificador Privado (`private`):** Não permite acesso por outros objetos a classes, métodos e atributos. O acesso é permitido **somente no local em que foram definidos**.
- **Pacotes (`Package`)** Um pacote é essencialmente um diretório que armazena um conjunto de classes. Classes com afinidade e propósito semelhantes são agrupadas. Para usá-las, utilizamos a diretiva `import`.

Exemplos de uso da diretiva `import`:

- `Import java.util.Date`: Indica o uso da classe `Date` que está no pacote `java.util`.
- `Import java.io.*`: Indica o uso de qualquer classe dentro do pacote `java.io`.
- `Import java.awt.*`: Indica o uso de qualquer classe do pacote `java.awt`.

**Vantagens do Encapsulamento**: O encapsulamento contribui para:

- Reduzir o tamanho do código.
- Tornar o código mais legível.
- Diminuir os erros de programação.
#### Exemplo 0701

```java

```
### Métodos Get e Set (Acessando Dados Privados)

Se um atributo é definido como `{java} private` (privado), ele não pode ser acessado diretamente por outros objetos. A solução é criar **métodos públicos** dentro da classe que permitem operações específicas sobre esses atributos. É comum fornecer métodos **"Get"** (para adquirir/ler o valor atual) e **"Set"** (para fixar/modificar o valor) para cada atributo privado.

**Exemplos GET e SET**.
```java
// Class java com get e set
class Veiculo{
	public String nome;
	private float velocidade;

	public void setVelocidade(float velocidade){
		this.velocidade = velocidade;
	}
	public float getVelocidade(){
		return (velocidade);
	}

	public void acelera(){
		if(velocidade < 100){
			velocidade++;
		}
	}
	public void frea(){
		if(velocidade > 0){
			velocidade--;
		}
	}
}
// class main que chama a classe Veiculo
public class exemplo0701 {
	public static void main(String[] args){
		Veiculo v1 = new Veiculo();
		v1.nome = "Gol";
		v1.setVelocidade(80);
		for(int i = 1; i <= 25; i++){
			v1.acelera();
		}
		System.out.println("Velocidade = " + v1.getVelocidade());
		v1.setVelocidade(10);
		for(int i = 1; i <= 25; i++){
			v1.frea();
		}
		System.out.println("Velocidade = " + v1.getVelocidade());
	}
}
```
## Escopo de Variáveis

O escopo (alcance) de uma variável define até onde ela pode ser acessada no código.

- **Variáveis de Instância (dentro da classe):** Variáveis declaradas dentro da classe, mas fora de qualquer método ou bloco, existem no escopo da classe e podem ser usadas dentro do objeto.
- **Variáveis Locais (dentro de métodos/blocos):** Variáveis declaradas dentro de um método, construtor ou bloco de código (como `if` ou _loopings_) só podem ser acessadas dentro daquele escopo específico.

O material ilustra a diferença com as variáveis `age` e `name` na classe `Person2`:

- A variável `age` é definida fora do método (linha 4) e existe no escopo da classe `Person2`.
- O atributo `name` é declarado dentro do método `displayName` (linha 6) e existirá **somente dentro desse método**.

Para que uma variável seja vista por todo o objeto, ela deve ser identificada com o modificador `public`. Variáveis locais e de instância são armazenadas em diferentes locais da memória.

## Construtores

Construtores são métodos especiais responsáveis por **construir e inicializar um objeto com determinados valores**. Eles são invocados pelo operador `new`.

**Regras Essenciais do Construtor**

1. O construtor deve ter, obrigatoriamente, **o mesmo nome (idêntico) da classe** em que se encontra.
2. **Construtor Default:** Se você não declarar um construtor, o Java assume um construtor padrão, que inicializa as variáveis com valores _default_:
    - Variáveis numéricas: Zero.
    - Valores lógicos (`boolean`): `False`.
    - Objetos: `Null`.

**Sintaxe para Construtores**:

```java
[modifiers] class ClassName{
[modifier] ConstructorName([arguments]){
code_block
}
}
```

O material lista vários exemplos de métodos construtores.

**Overloading de Construtores** Assim como é permitido fazer _overloading_ (sobrecarga) de métodos, também é possível ter **overloading de construtores**. Isso significa definir múltiplos construtores com o mesmo nome (o nome da classe), contanto que eles tenham listas de parâmetros diferentes (em número, tipo ou ordem).

## Destrutores (Finalizers)

Os destrutores, ou _finalizers_, têm a função oposta aos construtores. Enquanto os construtores alocam espaço na memória, **os destrutores liberam os recursos** utilizados pelos objetos durante a execução do programa.

O método destrutor simplesmente "passa uma borracha" nos endereços de memória alocados para o objeto em questão, liberando recursos do sistema.

O material apresenta um exemplo de reatribuição que torna o objeto anterior elegível para a finalização:

```java
Cliente c1
c1=new cliente(“Isabela”);
C1=new cliente(“Tatiana”);
```